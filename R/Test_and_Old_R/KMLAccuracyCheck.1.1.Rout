
R version 2.15.1 (2012-06-22) -- "Roasted Marshmallows"
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-redhat-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

[Previously saved workspace restored]

During startup - Warning message:
Setting LC_CTYPE failed, using "C" 
> #! /usr/bin/R -f
> ##############################################################################################################
> # Title      : KMLAccuracyCheck_1.1.R
> # Purpose    : Development of QAQC accuracy assessment side of Google Earth/Maps Africa field mapping project
> # Author     : Lyndon Estes
> # Draws from : GMap.grid.R, GMap.server.[1|1.1].R; GMap.acc.check.1.R; GMap.QAQC.check.1.1.R
> #              KMLAccuracyCheck_1.0.R
> # Used by    : 
> # Notes      : Created 21/10/2012
> #              Note on the True Skill Statistic: This can be negative, so for now I am letting it be negative,
> #              and the whole error metric can be set to 0 if this is the case (occurs when user maps fields
> #              but there aren't any)
> ##############################################################################################################
> 
> # Libraries
> library(RPostgreSQL)
Loading required package: DBI
> library(rgdal)
Loading required package: sp
Geospatial Data Abstraction Library extensions to R successfully loaded
Loaded GDAL runtime: GDAL 1.7.3, released 2010/11/10
Path to GDAL shared files: /usr/share/gdal
Loaded PROJ.4 runtime: Rel. 4.7.1, 23 September 2009, [PJ_VERSION: 470]
Path to PROJ.4 shared files: (autodetected)
> library(rgeos)
Loading required package: stringr
Loading required package: plyr
rgeos: (SVN revision 348)
 GEOS runtime version: 3.3.2-CAPI-1.7.2 
 Polygon checking: TRUE 

> 
> # Paths and connections
> drv <- dbDriver("PostgreSQL")
> con <- dbConnect(drv, dbname = "afmap", user = "afmap", password = "AfM@p")
> con2 <- dbConnect(drv, dbname = "SouthAfrica", user = "***REMOVED***", password = "***REMOVED***")
> 
> # Input args
> args <- commandArgs(TRUE)
> kmlid <- args[1]  # ID of grid cell 
> #kmlid <- 27209 # qaqc site with fields
> assignmentid <- args[2]  # Job identifier
> #assignmentid <- "1A2BC3463"
> 
> print(kmlid)
[1] "27209"
> print(assignmentid)
[1] "1A2BC3463"
> 
> # Hardcoded data
> # Projections 
> alb <- "+proj=aea +lat_1=-18 +lat_2=-32 +lat_0=0 +lon_0=24 +x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
> gcs <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
> 
> ##############################################################################################################
> # Functions: 
> accStatsSum <- function(tp, fp, tn, fn) {
+   # Calculate error statistics for two class contingency table
+   agree <- tp / sum(tp, fn)  # Simple agreement class 1
+   if(is.na(agree)) agree <- 0  # Set to 0 if NA
+   accuracy <- sum(tp, tn) / sum(tp, tn, fp, fn)
+   TSS <- agree + (tn / (fp + tn)) - 1  # Sens + specificity - 1
+   r1 <- round(accuracy * 100, 1)
+   r2 <- round(TSS, 2)
+   out <- c(r1, r2)
+   names(out) <- c("accuracy", "TSS")          
+   return(out)
+ }
> 
> mapError <- function(maps, truth, region) {
+ # Calculates mapping accuracy for polygons relative to a "true" set of polygons
+ # Args: 
+ #   maps: The input polygons to check - can be null in case where QAQC fields exist but user maps none
+ #   truth: The polygons against which which accuracy will be assessed - can be NULL in case where user maps
+ #     exist but "truth" maps do not
+ #   region: A polygon defining the region in which accuracy is assessed
+  
+   if(is.null(truth)) {
+     null <- region  # Actual null area is whole region
+     tp <- 0  # True positive area is 0
+     fp <- maps  # False positive area is all of maps
+     fn <- 0  # No false negative area because there are no fields
+     tn <- gDifference(spgeom1 = null, spgeom2 = maps, byid = F)  # false negative area (maps no, truth yes)
+   } 
+   if(is.null(maps)) {
+     null <- gDifference(spgeom1 = region, spgeom2 = truth, byid = F)  # Actual null area in mapping region 
+     tp <- 0  # No user maps, no true positive
+     fp <- 0  # No user maps, no false positives
+     fn <- truth  # False negative area is all of truth
+     tn <- null  # True negative area is null - user gets credit for this area, even if missed fields
+   }
+   if(!is.null(truth) & !is.null(maps)) {
+     null <- gDifference(spgeom1 = region, spgeom2 = truth, byid = F)  # Actual null area in mapping region 
+     tp <- gIntersection(spgeom1 = truth, spgeom2 = maps, byid = F)  # true positives (overlap of maps & truth)
+     fp <- gDifference(spgeom1 = maps, spgeom2 = truth, byid = F)  # false positive area (maps yes, truth no)
+     fn <- gDifference(spgeom1 = truth, spgeom2 = maps, byid = F)  # false negative area (maps no, truth yes)
+     tn <- gDifference(spgeom1 = null, spgeom2 = maps, byid = F)  # false negative area (maps no, truth yes)
+   }
+   areas <- sapply(list(tp, fp, tn, fn), function(x) ifelse(is.object(x), gArea(x), x))
+   list(accStatsSum(areas[1], areas[2], areas[3], areas[4]), tp, fp, fn, tn)
+ }
> 
> createSPPolyfromWKT <- function(geom.tab, crs) {
+ # Function for reading in and creating SpatialPolygonsDataFrame from PostGIS
+ # Args: 
+ #   geom.tab: Dataframe with geometry and identifiers in it. Identifier must be 1st column, geometries 2nd col  
+ #   crs: Coordinate reference system
+ # Returns: 
+ #   A SpatialPolygonsDataFrame
+   polys <- tst <- sapply(1:nrow(geom.tab), function(x) {
+     poly <- as(readWKT(geom.tab[x, 2], p4s = crs), "SpatialPolygonsDataFrame")
+     poly@data$ID <- geom.tab[x, 1]
+     newid <- paste(x)
+     poly <- spChFIDs(poly, newid)
+     return(poly)
+   })
+   polyspdf <- do.call("rbind", polys)
+ }
> 
> countError <- function(qaqc, kml) {
+ # Calculates percent agreement between number of fields in qaqc and user kmls
+ # Args: 
+ #  qaqc: QAQC spatial object, or NULL if one doesn't exist
+ #  kml: User mapped fields, or NULL if they don't exist
+ # Returns: Score between 0-1
+ # Notes: Rearranges numerator and denominator of equation according to whether user mapped fields are more 
+ # or less than QAQC fields
+   qaqc.row <- ifelse(is.null(qaqc), 0, nrow(qaqc))
+   kml.row <- ifelse(is.null(kml), 0, nrow(kml))
+   cden <- ifelse(qaqc.row >= kml.row, qaqc.row, kml.row)
+   cnu1 <- ifelse(qaqc.row >= kml.row, qaqc.row, kml.row)
+   cnu2 <- ifelse(qaqc.row >= kml.row, kml.row, qaqc.row)
+   cnterr <- 1 - (cnu1 - cnu2) / cden  # Percent agreement
+   return(cnterr)
+ }
> ##############################################################################################################
> 
> # First check if the QAQC site is null or not
> qaqc.sql <- paste("select fields from newqaqc_sites where id=", kmlid, sep = "")
> qaqc.hasfields <- dbGetQuery(con2, qaqc.sql)
> qaqc.hasfields <- qaqc.hasfields$fields
> 
> # Read in user data
> user.sql <- paste("select name,ST_AsEWKT(geom) from user_maps where assignment_id=", "'", 
+                   assignmentid, "'", " order by name", sep = "")
> user.geom.tab <- dbGetQuery(con2, user.sql)  # Collect user data and fields geometries
> user.hasfields <- ifelse(nrow(user.geom.tab) > 0, "Y", "N")  # Need to get this right
> 
> # Error checks begin
> #  Where no QAQC site is recorded
> if((qaqc.hasfields == "N") & (user.hasfields == "N")) {
+     print("No QAQC or User fields")
+     err <- 1  # Case 1: A null qaqc site recorded as null by the observer; score set to 1
+ } 
> if((qaqc.hasfields == "N") & (user.hasfields == "Y"))   {
+   print("No QAQC fields, but there are User fields") 
+   #err <- 0  # Case 2: A null qaqc site where observer mapped fields; score set to 0
+   # Pick up grid cell from qaqc table, for background location
+   #grid.sql <- paste("SELECT ST_AsEWKT(geom) from sa1kgrid where id=", kmlid, sep = "")
+   grid.sql <- paste("SELECT id,ST_AsEWKT(geom) from newqaqc_sites where id=", kmlid, sep = "")
+   grid.geom.tab <- dbGetQuery(con2, grid.sql)
+   grid.geom.tab[, 2] <- gsub("^SRID=*.*;", "", grid.geom.tab[, 2])
+   grid.poly <- createSPPolyfromWKT(geom.tab = grid.geom.tab, crs = alb)
+     
+   # Pick up user maps
+   #user.sql <- paste("SELECT name,ST_AsEWKT(geom) from user_maps where assignment_id=", 
+   #                  "'", assignmentid, "'", sep = "")
+   #user.sql <- paste("SELECT ST_AsEWKT(geom) from user_maps where gid in", " (", paste(gid, collapse = ","), 
+   #                  ")", sep = "")
+   user.geom.tab[, 2] <- gsub("^SRID=*.*;", "", user.geom.tab[, 2])
+   user.poly.gcs <- createSPPolyfromWKT(geom.tab = user.geom.tab, crs = gcs)
+   user.poly <- spTransform(user.poly.gcs, CRSobj = CRS(alb))  # Transform to Albers
+     
+   # Accuracy measures
+   count.error <- 0  # Count accuracy is zero if QAQC has no fields but user maps even 1 field
+     
+   # Mapped area differences inside the target grid cell
+   user.poly.in <- gIntersection(spgeom1 = grid.poly, spgeom2 = user.poly, byid = F)  # Turker maps in grid
+   inres <- mapError(maps = user.poly.in, truth = NULL, region = grid.poly)  # Main error metric - TSS
+     
+   # Secondary metric - Sensitivity of results outside of kml grid
+   out.error <- 0  # reduces to 0, because there is neither true positive nor false negative
+     
+   # Combine error metric
+   # Hardcoded, arbitrary weightings assigned to each of the 3 error metrics
+   err <- count.error * 0.1 + unname(inres[[1]][2]) * 0.6 + out.error * 0.3
+   err.out <- c("total_error" = err, "count_error" = count.error, "out_error" = out.error, 
+                "in_error" = unname(inres[[1]][2]))
+ }
> 
> # Possibility 3. QAQC has fields, User has no fields 
> if(qaqc.hasfields == "Y") {
+   # Pick up grid cell from qaqc table, for background location
+   grid.sql <- paste("SELECT id,ST_AsEWKT(geom) from newqaqc_sites where id=", kmlid, sep = "")
+   grid.geom.tab <- dbGetQuery(con2, grid.sql)
+   grid.geom.tab[, 2] <- gsub("^SRID=*.*;", "", grid.geom.tab[, 2])
+   grid.poly <- createSPPolyfromWKT(geom.tab = grid.geom.tab, crs = alb)
+  
+   # Pick-up QAQC poly
+   qaqc.fields.sql <- paste("select id,ST_AsEWKT(geom) from qaqcfields where id=", kmlid, sep = "")
+   qaqc.geom.tab <- dbGetQuery(con2, qaqc.fields.sql)
+   qaqc.geom.tab[, 2] <- gsub("^SRID=*.*;", "", qaqc.geom.tab[, 2])
+   qaqc.poly <- createSPPolyfromWKT(geom.tab = qaqc.geom.tab, crs = alb)
+   
+   if(user.hasfields == "N") {
+     print("QAQC fields but no User fields")
+     # Accuracy measures
+     count.error <- 0  # Count accuracy is zero if QAQC has fields but user maps none
+    
+     # Mapped area differences inside the target grid cell
+     qaqc.poly.in <- gIntersection(spgeom1 = grid.poly, spgeom2 = qaqc.poly, byid = F)  # QAQC inside grid cell
+     inres <- mapError(maps = NULL, truth = qaqc.poly.in, region = grid.poly)  # Main error metric - TSS
+    
+     # Secondary metric - Sensitivity of results outside of kml grid
+     out.error <- 0  # reduces to 0, because there is neither true positive nor false negative
+    
+     # Combine error metric
+     # Hardcoded, arbitrary weightings assigned to each of the 3 error metrics
+     err <- count.error * 0.1 + unname(inres[[1]][2]) * 0.6 + out.error * 0.3
+     err.out <- c("total_error" = err, "count_error" = count.error, "out_error" = out.error, 
+                  "in_error" = unname(inres[[1]][2]))    
+   } else if(user.hasfields == "Y") {
+     print("QAQC fields and User fields")
+    
+     # Fetch user fields
+     user.geom.tab[, 2] <- gsub("^SRID=*.*;", "", user.geom.tab[, 2])
+     user.poly.gcs <- createSPPolyfromWKT(geom.tab = user.geom.tab, crs = gcs)
+     user.poly <- spTransform(user.poly.gcs, CRSobj = CRS(alb))  # Transform to Albers
+    
+     # Accuracy measures
+     count.error <- countError(qaqc = qaqc.poly, kml = user.poly)  # Count accuracy
+    
+     # Mapped area differences inside the target grid cell
+     user.poly.in <- gIntersection(spgeom1 = grid.poly, spgeom2 = user.poly, byid = F)  # Turker maps in grid
+     qaqc.poly.in <- gIntersection(spgeom1 = grid.poly, spgeom2 = qaqc.poly, byid = F)  # QAQC inside grid cell
+     user.poly.out <- gDifference(spgeom1 = user.poly, spgeom2 = grid.poly, byid = F)  # Turker maps out 
+     qaqc.poly.out <- gDifference(spgeom1 = qaqc.poly, spgeom2 = grid.poly, byid = F)  # QAQC outside grid cell
+     inres <- mapError(maps = user.poly.in, truth = qaqc.poly.in, region = grid.poly)  # Error metric - TSS
+    
+     # Secondary metric - Sensitivity of results outside of kml grid
+     if(is.null(user.poly.out) & is.null(qaqc.poly.out)) {
+       print("No QAQC or User fields outside of grid")
+       out.error <- 1  
+     } else if(!is.null(user.poly.out) & !is.null(qaqc.poly.out)) {
+       print("Both QAQC and User fields outside of grid")
+       tpo <- gIntersection(spgeom1 = qaqc.poly.out, spgeom2 = user.poly.out)  # true positives (overlap)
+       fpo <- gDifference(spgeom1 = qaqc.out, spgeom2 = kml.out)  # true positives (overlap)
+       areaso <- sapply(list(tpo, fpo), function(x) gArea(x))
+       out.error <- areaso[1] / sum(areaso)
+     } else {
+       print("Either QAQC or User fields outside of grid, but not both")
+       out.error <- 0
+     }
+    
+     # Combine error metric
+     # Hardcoded, arbitrary weightings assigned to each of the 3 error metrics
+     err <- count.error * 0.1 + unname(inres[[1]][2]) * 0.6 + out.error * 0.3
+     err.out <- c("total_error" = err, "count_error" = count.error, "out_error" = out.error, 
+                  "in_error" = unname(inres[[1]][2]))
+   }
+ } 
[1] "QAQC fields but no User fields"
> 
> # Note: I want to keep some of the additional error metrics, if possible.  I can write them from here into 
> # the database, or pass them all out to python, and have the python code handle that.  
> # For now, I am just passing out the primary error metric, which I am setting to zero if is is negative
> cat(ifelse(err.out[1] < 0, 0, err.out[1])) 
0> cat("\n")

>  
> 
> proc.time()
   user  system elapsed 
  0.824   0.035   0.892 
